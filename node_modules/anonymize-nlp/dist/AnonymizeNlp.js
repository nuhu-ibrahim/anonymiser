"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnonymizeNlp = void 0;
const regexPatterns_1 = require("./common/regexPatterns");
const compromise_1 = __importDefault(require("compromise"));
class AnonymizeNlp {
    constructor(typesToAnonymize = regexPatterns_1.anonymizeTypeOptions, typesToExclude = []) {
        this.maskMaps = {};
        const typesToAnonymizeWithoutExcluded = typesToAnonymize.filter((type) => !typesToExclude.includes(type));
        this.typesToAnonymize = typesToAnonymizeWithoutExcluded;
        this.setEmptyMaskMaps();
    }
    anonymize(input) {
        this.setEmptyMaskMaps();
        let output = input;
        const docTerms = this.processDoc(input);
        output = this.replaceWithMasks(docTerms, output);
        return output;
    }
    deAnonymize(input) {
        let deAnonymizedInput = input;
        this.typesToAnonymize.forEach((type) => {
            this.maskMaps[type].forEach((key, value) => {
                deAnonymizedInput = deAnonymizedInput.split(key).join(value);
            });
        });
        this.setEmptyMaskMaps();
        return deAnonymizedInput;
    }
    replaceWithMasks(docTerms, output) {
        let outputRes = output;
        docTerms.forEach((term) => {
            const { text, tag } = term;
            const mask = this.mask(text, tag);
            outputRes = outputRes.replace(text, mask);
        });
        return outputRes;
    }
    getTerms(doc) {
        return [...doc.emails().out('offset'), ...doc.money().out('offset'), ...doc.organizations().out('offset'), ...doc.people().out('offset'), ...doc.phoneNumbers().out('offset')];
    }
    createDocTermsFromTerms(processedTerms, docObject, term) {
        const reversedTags = term.tags.reverse();
        const foundTag = reversedTags.find((tag) => this.typesToAnonymize.includes(tag.toLowerCase()));
        const { text } = term;
        if (foundTag) {
            processedTerms.push({ start: docObject.offset.start, tag: foundTag, text });
        }
        return processedTerms;
    }
    createUniqueAndSortedTerms(processedTerms) {
        const uniqueProcessedTerms = Array.from(processedTerms.reduce((map, term) => map.set(term.text + term.start + term.tag, term), new Map()).values());
        const sortedProcessedDocTerms = uniqueProcessedTerms.sort((a, b) => {
            const startDiff = a.start - b.start;
            if (startDiff !== 0) {
                return startDiff;
            }
            return b.text.length - a.text.length;
        });
        return sortedProcessedDocTerms;
    }
    processDoc(input) {
        let processedTerms = [];
        processedTerms = this.processTerms(input, processedTerms);
        processedTerms = this.processWithRegex(input, processedTerms);
        return this.createUniqueAndSortedTerms(processedTerms);
    }
    processTerms(input, processedTerms) {
        const doc = (0, compromise_1.default)(input);
        const processedDoc = this.getTerms(doc);
        processedDoc.forEach((docObject) => {
            const { terms } = docObject;
            terms.forEach((term) => {
                processedTerms = this.createDocTermsFromTerms(processedTerms, docObject, term);
            });
        });
        return processedTerms;
    }
    processWithRegex(input, processedTerms) {
        const filteredRegexPatterns = regexPatterns_1.regexPatterns.filter((ptrn) => this.typesToAnonymize.includes(ptrn.key));
        filteredRegexPatterns.forEach((ptrn) => {
            const { regex, key } = ptrn;
            let match;
            const rx = new RegExp(regex, 'igu');
            while ((match = rx.exec(input)) !== null) {
                processedTerms.push({
                    start: match.index,
                    tag: key,
                    text: match[0],
                });
            }
        });
        return processedTerms;
    }
    setEmptyMaskMaps() {
        this.typesToAnonymize.forEach((type) => {
            this.maskMaps[type] = new Map();
        });
    }
    mask(text, tag) {
        const lowerCaseTag = tag.toLowerCase();
        if (!this.maskMaps[lowerCaseTag]) {
            this.maskMaps[lowerCaseTag] = new Map();
        }
        const { size } = this.maskMaps[lowerCaseTag];
        const maskedValue = `<${tag.toUpperCase()}${size > 0 ? size : ''}>`;
        this.maskMaps[lowerCaseTag].set(text, maskedValue);
        return this.maskMaps[lowerCaseTag].get(text);
    }
}
exports.AnonymizeNlp = AnonymizeNlp;
